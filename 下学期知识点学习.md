1. Dictionary 字典类

   对于字典类来说，组成其的基本单位是键值对。

   键值对，顾名思义，其由“键”和“值”组成配对关系，从而将数值和其名称强绑定在一起。

   值得注意的是，键必须是唯一的，而值允许出现完全相同的。

   对于字典类型来说，键到值之间的查找是非常迅速的，有利于游戏开发中增加运行效率。

2. delegate 委托，event 事件

    delegate，即委托，其形式实际上有些类似于C语言中的函数指针，但是也有和函数指针不同的地方。比如。对于委托类，我们可以将方法挂载到委托类中，在调用(Invoke)时，就可以使用其中的方法。而且，在调用时可以通过+=和-=对委托类中进行多个函数的挂载，彼时委托类姜按照挂载的顺序依次启动各方法。

   event，即事件，其本质上是使用类似属性的方法对委托进行封装，使委托本身不能被=直接赋值，增加了delegate行为的安全性。

3. 常用设计模式：factory 工厂模式；abstract factory 抽象工厂；singleton 单例 ；observer 观察者模式

   factory工厂模式：我们在新建一个对象时不使用new来建立新的对象，而是使用工厂模式来建立，具体的来说，就是引用工厂方法，工厂方法下辖的类中的方法再接收数据，自行建立对象，再返回给引用者。此时工厂可以做到的是：帮助使用者简化代码量(特别是需要大量使用建立复杂对象时)；封装代码以使客户无法看到具体的新建细节等。

   abstract factory抽象工厂：抽象工厂实质上是由工厂模式发展来的结果，它相对于工厂模式的优势是它将统一的工厂细分为了多个有单一职能的工厂，能够帮助我们在增加新产品等拓展时更好的进行维护。

   singleton 单例：单例模式的核心便是保证一个类中只有一个单一的实例，以保护类中此实例的唯一性。对于单例模式来说，我们需要做到的是：对于类中的构造方法设置为private，使其他类不能够进行调用，保持唯一实例；对于类自身的构造方法，使用判断条件保证类中实例唯一。在单例实现之后，我们可以得到一个唯一、静态的实例，同时还可以构造一个静态函数以使外界的类与此单例产生联系。

   observer 观察者模式：观察者模式分为两种对象：目标(Subject)与观察者(Observer)。目标中含有受观察者关注的事件，当某个事件达到判断条件时，目标会向观察者传递数据，而观察者仅负责接收数据。所以可以说，观察者模式是一种一对多的依赖关系。

